{"version":3,"sources":["../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../../app/lib/actions/auth-actions.ts","../../../../app/lib/prisma.ts","../../../../.next-internal/server/app/operations/delivery/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","'use server';\r\n\r\nimport { signIn, signOut } from '@/auth';\r\nimport { AuthError } from 'next-auth';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\nimport { z } from 'zod';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Schema for the initial password check\r\nconst PreAuthSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(6),\r\n});\r\n\r\nexport async function preAuthenticate(formData: FormData) {\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n\r\n    console.log('Pre-auth input:', { email, password });\r\n\r\n    const validatedFields = PreAuthSchema.safeParse({ email, password });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: 'Invalid email or password format.' };\r\n    }\r\n\r\n    try {\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n        if (!user) return { error: 'Invalid credentials.' };\r\n\r\n        const passwordsMatch = await bcrypt.compare(password, user.password);\r\n        if (!passwordsMatch) return { error: 'Invalid credentials.' };\r\n\r\n        // Generate OTP\r\n        const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n        const otpExpires = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\r\n\r\n        // Save OTP to DB\r\n        await prisma.user.update({\r\n            where: { email },\r\n            // @ts-ignore\r\n            data: { otp, otpExpires },\r\n        });\r\n\r\n        console.log(`ðŸ” OTP for ${email}: ${otp}`); // In real app, send via email/SMS\r\n\r\n        return { success: true, message: 'OTP sent to your email.' };\r\n    } catch (error) {\r\n        console.error('Pre-auth error:', error);\r\n        return { error: 'Something went wrong.' };\r\n    }\r\n}\r\n\r\nexport async function authenticate(\r\n    prevState: string | undefined,\r\n    formData: FormData,\r\n) {\r\n    try {\r\n        await signIn('credentials', formData);\r\n    } catch (error) {\r\n        if (error instanceof AuthError) {\r\n            switch (error.type) {\r\n                case 'CredentialsSignin':\r\n                    return 'Invalid OTP or credentials.';\r\n                default:\r\n                    return 'Something went wrong.';\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\nconst RegisterSchema = z.object({\r\n    name: z.string().min(2, { message: 'Name must be at least 2 characters long.' }),\r\n    email: z.string().email({ message: 'Please enter a valid email address.' }),\r\n    password: z.string().min(6, { message: 'Password must be at least 6 characters long.' }),\r\n    confirmPassword: z.string()\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n    message: \"Passwords don't match\",\r\n    path: [\"confirmPassword\"],\r\n});\r\n\r\nexport interface RegisterState {\r\n    error?: {\r\n        name?: string[];\r\n        email?: string[];\r\n        password?: string[];\r\n        confirmPassword?: string[];\r\n        form?: string[];\r\n    };\r\n    success?: boolean;\r\n    message?: string;\r\n}\r\n\r\nexport async function registerUser(prevState: RegisterState, formData: FormData): Promise<RegisterState> {\r\n    const name = formData.get('name') as string;\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n    const confirmPassword = formData.get('confirmPassword') as string;\r\n\r\n    const validatedFields = RegisterSchema.safeParse({ name, email, password, confirmPassword });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: validatedFields.error.flatten().fieldErrors };\r\n    }\r\n\r\n    try {\r\n        const existingUser = await prisma.user.findUnique({ where: { email } });\r\n        if (existingUser) {\r\n            return { error: { email: ['Email already in use.'] } };\r\n        }\r\n\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                name,\r\n                email,\r\n                password: hashedPassword,\r\n                role: 'USER', // Default role\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Account created successfully. Please log in.' };\r\n    } catch (error) {\r\n        console.error('Registration error:', error);\r\n        return { error: { form: ['Something went wrong. Please try again.'] } };\r\n    }\r\n}\r\n\r\nexport async function signOutAction() {\r\n    await signOut();\r\n}\r\n","import { PrismaClient } from '@prisma/client';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma =\r\n    globalForPrisma.prisma ||\r\n    new PrismaClient({\r\n        log: ['query'],\r\n    });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n","export {preAuthenticate as '40d12781802ab3aab57f0ca9725d2f90dea69b1725'} from 'ACTIONS_MODULE0'\nexport {authenticate as '6089715bce84d2d6ec2b584d091fb47ceb9a4a00c4'} from 'ACTIONS_MODULE0'\nexport {registerUser as '60b78c7cae6fecc38121e5674933901f3d21b0f3dc'} from 'ACTIONS_MODULE0'\nexport {signOutAction as '00113b3ea0d5bdec66bf3a02a9e7d2d58ec09f7cf9'} from 'ACTIONS_MODULE0'\nexport {createOutboundOperation as '4048651bffbe37641cefaa45bbef7e6267e0e9f505'} from 'ACTIONS_MODULE1'\nexport {validateOperation as '40cb085986bcc83091452049a13d27533875576451'} from 'ACTIONS_MODULE1'\n"],"names":["registerServerReference","ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"6CAAoD,OAAA,cAAA,CAAA,EAAA,aAAA,oCAC3CA,0BAAAA,qCAAAA,EAAAA,uBAAuB,YAAQ,CAAA,CAAA,IAAA,iCCEjC,SAASC,EAAyBC,CAAc,EACrD,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQE,MAAM,CAAED,IAAK,CACvC,IAAME,EAASH,CAAO,CAACC,EAAE,CACzB,GAAsB,YAAlB,AAA8B,OAAvBE,EACT,MAAM,OAAA,cAEL,CAFK,AAAIC,MACR,CAAC,2DAA2D,EAAE,OAAOD,EAAO;AAAA,oEAAuE,CAAC,EADhJ,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EAEJ,CACF,0EATgBJ,2BAAAA,qCAAAA,8CCDhB,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OAAA,IAAA,EAAA,EAAA,CAAA,CAAA,MACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,oBAEA,IAAM,EAAS,IAAI,EAAA,YAAY,CAGzB,EAAgB,EAAA,CAAC,CAAC,MAAM,CAAC,CAC3B,MAAO,EAAA,CAAC,CAAC,MAAM,GAAG,KAAK,GACvB,SAAU,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,EAC7B,GAEO,eAAe,EAAgB,CAAkB,EACpD,IAAM,EAAQ,EAAS,GAAG,CAAC,SACrB,EAAW,EAAS,GAAG,CAAC,YAM9B,GAJA,QAAQ,GAAG,CAAC,kBAAmB,OAAE,WAAO,CAAS,GAI7C,CAFoB,AAEnB,EAFiC,SAAS,CAAC,OAAE,WAAO,CAAS,GAE7C,OAAO,CACxB,CAD0B,KACnB,CAAE,MAAO,mCAAoC,EAGxD,GAAI,CACA,IAAM,EAAO,MAAM,EAAO,IAAI,CAAC,UAAU,CAAC,CAAE,MAAO,OAAE,CAAM,CAAE,GAC7D,GAAI,CAAC,GAGD,CADmB,AAClB,MADwB,EAAA,OAAM,CAAC,AACf,OADsB,AACf,CADgB,EAAU,EAAK,QAAQ,EAFxD,MAAO,CAAE,MAAO,sBAAuB,EAMlD,IAAM,EAAM,KAAK,KAAK,CAAC,IAAyB,IAAhB,KAAK,MAAM,IAAa,QAAQ,GAC1D,EAAa,IAAI,KAAK,KAAK,GAAG,GAAK,IAAI,CAW7C,IAXkD,GAGlD,IAHyD,EAGnD,EAAO,IAAI,CAAC,GAHmD,GAG7C,CAAC,CACrB,MAAO,OAAE,CAAM,EAEf,KAAM,KAAE,aAAK,CAAW,CAC5B,GAEA,QAAQ,GAAG,CAAC,CAAC,WAAW,EAAE,EAAM,EAAE,EAAE,EAAA,CAAK,EAElC,CAFqC,AAEnC,QAAS,GAAM,QAAS,eAF6C,UAEnB,CAC/D,CAAE,MAAO,EAAO,CAEZ,OADA,QAAQ,KAAK,CAAC,kBAAmB,GAC1B,CAAE,MAAO,uBAAwB,CAC5C,CACJ,CAEO,eAAe,EAClB,CAA6B,CAC7B,CAAkB,EAElB,GAAI,CACA,MAAM,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,cAAe,EAChC,CAAE,MAAO,EAAO,CACZ,GAAI,aAAiB,EAAA,SAAS,CAC1B,CAD4B,EAEnB,sBADD,EAAM,IAAI,CAEV,MAAO,mCAEP,MAAO,uBAGnB,OAAM,CACV,CACJ,CAEA,IAAM,EAAiB,EAAA,CAAC,CAAC,MAAM,CAAC,CAC5B,KAAM,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,EAAG,CAAE,QAAS,0CAA2C,GAC9E,MAAO,EAAA,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,CAAE,QAAS,qCAAsC,GACzE,SAAU,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,EAAG,CAAE,QAAS,8CAA+C,GACtF,gBAAiB,EAAA,CAAC,CAAC,MAAM,EAC7B,GAAG,MAAM,CAAC,AAAC,GAAS,EAAK,QAAQ,GAAK,EAAK,eAAe,CAAE,CACxD,QAAS,wBACT,KAAM,CAAC,kBAAkB,AAC7B,GAcO,eAAe,EAAa,CAAwB,CAAE,CAAkB,EAC3E,IAAM,EAAO,EAAS,GAAG,CAAC,QACpB,EAAQ,EAAS,GAAG,CAAC,SACrB,EAAW,EAAS,GAAG,CAAC,YACxB,EAAkB,EAAS,GAAG,CAAC,mBAE/B,EAAkB,EAAe,SAAS,CAAC,MAAE,QAAM,WAAO,EAAU,iBAAgB,GAE1F,GAAI,CAAC,EAAgB,OAAO,CACxB,CAD0B,KACnB,CAAE,MAAO,EAAgB,KAAK,CAAC,OAAO,GAAG,WAAW,AAAC,EAGhE,GAAI,CAEA,GADqB,CACjB,KADuB,EAAO,IAAI,CAAC,EACrB,QAD+B,CAAC,CAAE,MAAO,OAAE,CAAM,CAAE,GAEjE,MAAO,CAAE,MAAO,CAAE,MAAO,CAAC,wBAAyB,AAAD,CAAG,EAGzD,IAAM,EAAiB,MAAM,EAAA,OAAM,CAAC,IAAI,CAAC,EAAU,IAWnD,OATA,MAAM,EAAO,IAAI,CAAC,MAAM,CAAC,CACrB,KAAM,MACF,QACA,EACA,SAAU,EACV,KAAM,MACV,CACJ,GAEO,CAAE,QAAS,GAAM,QAAS,8CAA+C,CACpF,CAAE,MAAO,EAAO,CAEZ,OADA,QAAQ,KAAK,CAAC,sBAAuB,GAC9B,CAAE,MAAO,CAAE,KAAM,CAAC,0CAA0C,AAAC,CAAE,CAC1E,CACJ,CAEO,eAAe,IAClB,MAAM,CAAA,EAAA,EAAA,OAAA,AAAO,GACjB,iCAtHsB,EAuCA,EAyCA,EAoCA,IApHA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAuCA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAyCA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAoCA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,6HCpItB,IAAA,EAAA,EAAA,CAAA,CAAA,OAIO,IAAM,EAFP,AAGF,EAHE,CAAA,CAGc,MAAM,EACtB,IAAI,EAAA,YAAY,CAAC,CACb,IAAK,CAAC,QAAQ,AAClB,+CCRJ,IAAA,EAAA,EAAA,CAAA,CAAA,OAIA,EAAA,EAAA,CAAA,CAAA","ignoreList":[0,1]}