{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/app/lib/actions/auth-actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { signIn, signOut } from '@/auth';\r\nimport { AuthError } from 'next-auth';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\nimport { z } from 'zod';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Schema for the initial password check\r\nconst PreAuthSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(6),\r\n});\r\n\r\nexport async function preAuthenticate(formData: FormData) {\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n\r\n    console.log('Pre-auth input:', { email, password });\r\n\r\n    const validatedFields = PreAuthSchema.safeParse({ email, password });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: 'Invalid email or password format.' };\r\n    }\r\n\r\n    try {\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n        if (!user) return { error: 'Invalid credentials.' };\r\n\r\n        const passwordsMatch = await bcrypt.compare(password, user.password);\r\n        if (!passwordsMatch) return { error: 'Invalid credentials.' };\r\n\r\n        // Generate OTP\r\n        const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n        const otpExpires = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\r\n\r\n        // Save OTP to DB\r\n        await prisma.user.update({\r\n            where: { email },\r\n            // @ts-ignore\r\n            data: { otp, otpExpires },\r\n        });\r\n\r\n        console.log(`ðŸ” OTP for ${email}: ${otp}`); // In real app, send via email/SMS\r\n\r\n        return { success: true, message: 'OTP sent to your email.' };\r\n    } catch (error) {\r\n        console.error('Pre-auth error:', error);\r\n        return { error: 'Something went wrong.' };\r\n    }\r\n}\r\n\r\nexport async function authenticate(\r\n    prevState: string | undefined,\r\n    formData: FormData,\r\n) {\r\n    try {\r\n        await signIn('credentials', formData);\r\n    } catch (error) {\r\n        if (error instanceof AuthError) {\r\n            switch (error.type) {\r\n                case 'CredentialsSignin':\r\n                    return 'Invalid OTP or credentials.';\r\n                default:\r\n                    return 'Something went wrong.';\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\nconst RegisterSchema = z.object({\r\n    name: z.string().min(2, { message: 'Name must be at least 2 characters long.' }),\r\n    email: z.string().email({ message: 'Please enter a valid email address.' }),\r\n    password: z.string().min(6, { message: 'Password must be at least 6 characters long.' }),\r\n    confirmPassword: z.string()\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n    message: \"Passwords don't match\",\r\n    path: [\"confirmPassword\"],\r\n});\r\n\r\nexport interface RegisterState {\r\n    error?: {\r\n        name?: string[];\r\n        email?: string[];\r\n        password?: string[];\r\n        confirmPassword?: string[];\r\n        form?: string[];\r\n    };\r\n    success?: boolean;\r\n    message?: string;\r\n}\r\n\r\nexport async function registerUser(prevState: RegisterState, formData: FormData): Promise<RegisterState> {\r\n    const name = formData.get('name') as string;\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n    const confirmPassword = formData.get('confirmPassword') as string;\r\n\r\n    const validatedFields = RegisterSchema.safeParse({ name, email, password, confirmPassword });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: validatedFields.error.flatten().fieldErrors };\r\n    }\r\n\r\n    try {\r\n        const existingUser = await prisma.user.findUnique({ where: { email } });\r\n        if (existingUser) {\r\n            return { error: { email: ['Email already in use.'] } };\r\n        }\r\n\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                name,\r\n                email,\r\n                password: hashedPassword,\r\n                role: 'USER', // Default role\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Account created successfully. Please log in.' };\r\n    } catch (error) {\r\n        console.error('Registration error:', error);\r\n        return { error: { form: ['Something went wrong. Please try again.'] } };\r\n    }\r\n}\r\n\r\nexport async function signOutAction() {\r\n    await signOut();\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 194, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/.next-internal/server/app/settings/locations/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {preAuthenticate as '401024374ad4e484a00123d87e1aaee226eb95a960'} from 'ACTIONS_MODULE0'\nexport {authenticate as '60be66a202d772940bea322562258910466041fa00'} from 'ACTIONS_MODULE0'\nexport {registerUser as '6095436ed47bcbf1e0a77f7eb6a6084305dc033d5c'} from 'ACTIONS_MODULE0'\nexport {signOutAction as '000e01556ed40dbc2a4f10777b9e7c673edf275859'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n"],"names":["registerServerReference"],"mappings":"AAAA,oDAAoD;;;+BAC3CA,2BAAAA;;;eAAAA,QAAAA,uBAAuB;;;wBAAQ","ignoreList":[0]}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts"],"sourcesContent":["// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n"],"names":["ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"AAAA,+EAA+E;AAC/E,yEAAyE;AACzE,iEAAiE;;;;+BACjDA,4BAAAA;;;eAAAA;;;AAAT,SAASA,yBAAyBC,OAAc;IACrD,IAAK,IAAIC,IAAI,GAAGA,IAAID,QAAQE,MAAM,EAAED,IAAK;QACvC,MAAME,SAASH,OAAO,CAACC,EAAE;QACzB,IAAI,OAAOE,WAAW,YAAY;YAChC,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,2DAA2D,EAAE,OAAOD,OAAO,uEAAuE,CAAC,GADhJ,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;AACF","ignoreList":[0]}}]
}