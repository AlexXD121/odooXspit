{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 17, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/app/lib/actions/auth-actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { signIn, signOut } from '@/auth';\r\nimport { AuthError } from 'next-auth';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\nimport { z } from 'zod';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Schema for the initial password check\r\nconst PreAuthSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(6),\r\n});\r\n\r\nexport async function preAuthenticate(formData: FormData) {\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n\r\n    console.log('Pre-auth input:', { email, password });\r\n\r\n    const validatedFields = PreAuthSchema.safeParse({ email, password });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: 'Invalid email or password format.' };\r\n    }\r\n\r\n    try {\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n        if (!user) return { error: 'Invalid credentials.' };\r\n\r\n        const passwordsMatch = await bcrypt.compare(password, user.password);\r\n        if (!passwordsMatch) return { error: 'Invalid credentials.' };\r\n\r\n        // Generate OTP\r\n        const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n        const otpExpires = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\r\n\r\n        // Save OTP to DB\r\n        await prisma.user.update({\r\n            where: { email },\r\n            // @ts-ignore\r\n            data: { otp, otpExpires },\r\n        });\r\n\r\n        console.log(`ðŸ” OTP for ${email}: ${otp}`); // In real app, send via email/SMS\r\n\r\n        return { success: true, message: 'OTP sent to your email.' };\r\n    } catch (error) {\r\n        console.error('Pre-auth error:', error);\r\n        return { error: 'Something went wrong.' };\r\n    }\r\n}\r\n\r\nexport async function authenticate(\r\n    prevState: string | undefined,\r\n    formData: FormData,\r\n) {\r\n    try {\r\n        await signIn('credentials', formData);\r\n    } catch (error) {\r\n        if (error instanceof AuthError) {\r\n            switch (error.type) {\r\n                case 'CredentialsSignin':\r\n                    return 'Invalid OTP or credentials.';\r\n                default:\r\n                    return 'Something went wrong.';\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\nconst RegisterSchema = z.object({\r\n    name: z.string().min(2, { message: 'Name must be at least 2 characters long.' }),\r\n    email: z.string().email({ message: 'Please enter a valid email address.' }),\r\n    password: z.string().min(6, { message: 'Password must be at least 6 characters long.' }),\r\n    confirmPassword: z.string()\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n    message: \"Passwords don't match\",\r\n    path: [\"confirmPassword\"],\r\n});\r\n\r\nexport interface RegisterState {\r\n    error?: {\r\n        name?: string[];\r\n        email?: string[];\r\n        password?: string[];\r\n        confirmPassword?: string[];\r\n        form?: string[];\r\n    };\r\n    success?: boolean;\r\n    message?: string;\r\n}\r\n\r\nexport async function registerUser(prevState: RegisterState, formData: FormData): Promise<RegisterState> {\r\n    const name = formData.get('name') as string;\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n    const confirmPassword = formData.get('confirmPassword') as string;\r\n\r\n    const validatedFields = RegisterSchema.safeParse({ name, email, password, confirmPassword });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: validatedFields.error.flatten().fieldErrors };\r\n    }\r\n\r\n    try {\r\n        const existingUser = await prisma.user.findUnique({ where: { email } });\r\n        if (existingUser) {\r\n            return { error: { email: ['Email already in use.'] } };\r\n        }\r\n\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                name,\r\n                email,\r\n                password: hashedPassword,\r\n                role: 'USER', // Default role\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Account created successfully. Please log in.' };\r\n    } catch (error) {\r\n        console.error('Registration error:', error);\r\n        return { error: { form: ['Something went wrong. Please try again.'] } };\r\n    }\r\n}\r\n\r\nexport async function signOutAction() {\r\n    await signOut();\r\n}\r\n"],"names":[],"mappings":";;;;;;;IAgBsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/app/lib/actions/auth-actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { signIn, signOut } from '@/auth';\r\nimport { AuthError } from 'next-auth';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\nimport { z } from 'zod';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Schema for the initial password check\r\nconst PreAuthSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(6),\r\n});\r\n\r\nexport async function preAuthenticate(formData: FormData) {\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n\r\n    console.log('Pre-auth input:', { email, password });\r\n\r\n    const validatedFields = PreAuthSchema.safeParse({ email, password });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: 'Invalid email or password format.' };\r\n    }\r\n\r\n    try {\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n        if (!user) return { error: 'Invalid credentials.' };\r\n\r\n        const passwordsMatch = await bcrypt.compare(password, user.password);\r\n        if (!passwordsMatch) return { error: 'Invalid credentials.' };\r\n\r\n        // Generate OTP\r\n        const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n        const otpExpires = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\r\n\r\n        // Save OTP to DB\r\n        await prisma.user.update({\r\n            where: { email },\r\n            // @ts-ignore\r\n            data: { otp, otpExpires },\r\n        });\r\n\r\n        console.log(`ðŸ” OTP for ${email}: ${otp}`); // In real app, send via email/SMS\r\n\r\n        return { success: true, message: 'OTP sent to your email.' };\r\n    } catch (error) {\r\n        console.error('Pre-auth error:', error);\r\n        return { error: 'Something went wrong.' };\r\n    }\r\n}\r\n\r\nexport async function authenticate(\r\n    prevState: string | undefined,\r\n    formData: FormData,\r\n) {\r\n    try {\r\n        await signIn('credentials', formData);\r\n    } catch (error) {\r\n        if (error instanceof AuthError) {\r\n            switch (error.type) {\r\n                case 'CredentialsSignin':\r\n                    return 'Invalid OTP or credentials.';\r\n                default:\r\n                    return 'Something went wrong.';\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\nconst RegisterSchema = z.object({\r\n    name: z.string().min(2, { message: 'Name must be at least 2 characters long.' }),\r\n    email: z.string().email({ message: 'Please enter a valid email address.' }),\r\n    password: z.string().min(6, { message: 'Password must be at least 6 characters long.' }),\r\n    confirmPassword: z.string()\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n    message: \"Passwords don't match\",\r\n    path: [\"confirmPassword\"],\r\n});\r\n\r\nexport interface RegisterState {\r\n    error?: {\r\n        name?: string[];\r\n        email?: string[];\r\n        password?: string[];\r\n        confirmPassword?: string[];\r\n        form?: string[];\r\n    };\r\n    success?: boolean;\r\n    message?: string;\r\n}\r\n\r\nexport async function registerUser(prevState: RegisterState, formData: FormData): Promise<RegisterState> {\r\n    const name = formData.get('name') as string;\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n    const confirmPassword = formData.get('confirmPassword') as string;\r\n\r\n    const validatedFields = RegisterSchema.safeParse({ name, email, password, confirmPassword });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: validatedFields.error.flatten().fieldErrors };\r\n    }\r\n\r\n    try {\r\n        const existingUser = await prisma.user.findUnique({ where: { email } });\r\n        if (existingUser) {\r\n            return { error: { email: ['Email already in use.'] } };\r\n        }\r\n\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                name,\r\n                email,\r\n                password: hashedPassword,\r\n                role: 'USER', // Default role\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Account created successfully. Please log in.' };\r\n    } catch (error) {\r\n        console.error('Registration error:', error);\r\n        return { error: { form: ['Something went wrong. Please try again.'] } };\r\n    }\r\n}\r\n\r\nexport async function signOutAction() {\r\n    await signOut();\r\n}\r\n"],"names":[],"mappings":";;;;;;;IAuDsB,eAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/app/lib/actions/auth-actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { signIn, signOut } from '@/auth';\r\nimport { AuthError } from 'next-auth';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\nimport { z } from 'zod';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Schema for the initial password check\r\nconst PreAuthSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(6),\r\n});\r\n\r\nexport async function preAuthenticate(formData: FormData) {\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n\r\n    console.log('Pre-auth input:', { email, password });\r\n\r\n    const validatedFields = PreAuthSchema.safeParse({ email, password });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: 'Invalid email or password format.' };\r\n    }\r\n\r\n    try {\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n        if (!user) return { error: 'Invalid credentials.' };\r\n\r\n        const passwordsMatch = await bcrypt.compare(password, user.password);\r\n        if (!passwordsMatch) return { error: 'Invalid credentials.' };\r\n\r\n        // Generate OTP\r\n        const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n        const otpExpires = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\r\n\r\n        // Save OTP to DB\r\n        await prisma.user.update({\r\n            where: { email },\r\n            // @ts-ignore\r\n            data: { otp, otpExpires },\r\n        });\r\n\r\n        console.log(`ðŸ” OTP for ${email}: ${otp}`); // In real app, send via email/SMS\r\n\r\n        return { success: true, message: 'OTP sent to your email.' };\r\n    } catch (error) {\r\n        console.error('Pre-auth error:', error);\r\n        return { error: 'Something went wrong.' };\r\n    }\r\n}\r\n\r\nexport async function authenticate(\r\n    prevState: string | undefined,\r\n    formData: FormData,\r\n) {\r\n    try {\r\n        await signIn('credentials', formData);\r\n    } catch (error) {\r\n        if (error instanceof AuthError) {\r\n            switch (error.type) {\r\n                case 'CredentialsSignin':\r\n                    return 'Invalid OTP or credentials.';\r\n                default:\r\n                    return 'Something went wrong.';\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\nconst RegisterSchema = z.object({\r\n    name: z.string().min(2, { message: 'Name must be at least 2 characters long.' }),\r\n    email: z.string().email({ message: 'Please enter a valid email address.' }),\r\n    password: z.string().min(6, { message: 'Password must be at least 6 characters long.' }),\r\n    confirmPassword: z.string()\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n    message: \"Passwords don't match\",\r\n    path: [\"confirmPassword\"],\r\n});\r\n\r\nexport interface RegisterState {\r\n    error?: {\r\n        name?: string[];\r\n        email?: string[];\r\n        password?: string[];\r\n        confirmPassword?: string[];\r\n        form?: string[];\r\n    };\r\n    success?: boolean;\r\n    message?: string;\r\n}\r\n\r\nexport async function registerUser(prevState: RegisterState, formData: FormData): Promise<RegisterState> {\r\n    const name = formData.get('name') as string;\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n    const confirmPassword = formData.get('confirmPassword') as string;\r\n\r\n    const validatedFields = RegisterSchema.safeParse({ name, email, password, confirmPassword });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: validatedFields.error.flatten().fieldErrors };\r\n    }\r\n\r\n    try {\r\n        const existingUser = await prisma.user.findUnique({ where: { email } });\r\n        if (existingUser) {\r\n            return { error: { email: ['Email already in use.'] } };\r\n        }\r\n\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                name,\r\n                email,\r\n                password: hashedPassword,\r\n                role: 'USER', // Default role\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Account created successfully. Please log in.' };\r\n    } catch (error) {\r\n        console.error('Registration error:', error);\r\n        return { error: { form: ['Something went wrong. Please try again.'] } };\r\n    }\r\n}\r\n\r\nexport async function signOutAction() {\r\n    await signOut();\r\n}\r\n"],"names":[],"mappings":";;;;;;;IAgGsB,eAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/app/lib/actions/auth-actions.ts"],"sourcesContent":["'use server';\r\n\r\nimport { signIn, signOut } from '@/auth';\r\nimport { AuthError } from 'next-auth';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\nimport { z } from 'zod';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Schema for the initial password check\r\nconst PreAuthSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(6),\r\n});\r\n\r\nexport async function preAuthenticate(formData: FormData) {\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n\r\n    console.log('Pre-auth input:', { email, password });\r\n\r\n    const validatedFields = PreAuthSchema.safeParse({ email, password });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: 'Invalid email or password format.' };\r\n    }\r\n\r\n    try {\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n        if (!user) return { error: 'Invalid credentials.' };\r\n\r\n        const passwordsMatch = await bcrypt.compare(password, user.password);\r\n        if (!passwordsMatch) return { error: 'Invalid credentials.' };\r\n\r\n        // Generate OTP\r\n        const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n        const otpExpires = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes\r\n\r\n        // Save OTP to DB\r\n        await prisma.user.update({\r\n            where: { email },\r\n            // @ts-ignore\r\n            data: { otp, otpExpires },\r\n        });\r\n\r\n        console.log(`ðŸ” OTP for ${email}: ${otp}`); // In real app, send via email/SMS\r\n\r\n        return { success: true, message: 'OTP sent to your email.' };\r\n    } catch (error) {\r\n        console.error('Pre-auth error:', error);\r\n        return { error: 'Something went wrong.' };\r\n    }\r\n}\r\n\r\nexport async function authenticate(\r\n    prevState: string | undefined,\r\n    formData: FormData,\r\n) {\r\n    try {\r\n        await signIn('credentials', formData);\r\n    } catch (error) {\r\n        if (error instanceof AuthError) {\r\n            switch (error.type) {\r\n                case 'CredentialsSignin':\r\n                    return 'Invalid OTP or credentials.';\r\n                default:\r\n                    return 'Something went wrong.';\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\nconst RegisterSchema = z.object({\r\n    name: z.string().min(2, { message: 'Name must be at least 2 characters long.' }),\r\n    email: z.string().email({ message: 'Please enter a valid email address.' }),\r\n    password: z.string().min(6, { message: 'Password must be at least 6 characters long.' }),\r\n    confirmPassword: z.string()\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n    message: \"Passwords don't match\",\r\n    path: [\"confirmPassword\"],\r\n});\r\n\r\nexport interface RegisterState {\r\n    error?: {\r\n        name?: string[];\r\n        email?: string[];\r\n        password?: string[];\r\n        confirmPassword?: string[];\r\n        form?: string[];\r\n    };\r\n    success?: boolean;\r\n    message?: string;\r\n}\r\n\r\nexport async function registerUser(prevState: RegisterState, formData: FormData): Promise<RegisterState> {\r\n    const name = formData.get('name') as string;\r\n    const email = formData.get('email') as string;\r\n    const password = formData.get('password') as string;\r\n    const confirmPassword = formData.get('confirmPassword') as string;\r\n\r\n    const validatedFields = RegisterSchema.safeParse({ name, email, password, confirmPassword });\r\n\r\n    if (!validatedFields.success) {\r\n        return { error: validatedFields.error.flatten().fieldErrors };\r\n    }\r\n\r\n    try {\r\n        const existingUser = await prisma.user.findUnique({ where: { email } });\r\n        if (existingUser) {\r\n            return { error: { email: ['Email already in use.'] } };\r\n        }\r\n\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n        await prisma.user.create({\r\n            data: {\r\n                name,\r\n                email,\r\n                password: hashedPassword,\r\n                role: 'USER', // Default role\r\n            },\r\n        });\r\n\r\n        return { success: true, message: 'Account created successfully. Please log in.' };\r\n    } catch (error) {\r\n        console.error('Registration error:', error);\r\n        return { error: { form: ['Something went wrong. Please try again.'] } };\r\n    }\r\n}\r\n\r\nexport async function signOutAction() {\r\n    await signOut();\r\n}\r\n"],"names":[],"mappings":";;;;;;;IAoIsB,gBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///D:/Kargo/kargo/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createServerReference } from 'react-server-dom-webpack/client'\n"],"names":["callServer","createServerReference","findSourceMapURL"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IAMVC,qBAAqB,EAAA;eAArBA,QAAAA,qBAAqB;;IALrBC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;wBAKK","ignoreList":[0]}}]
}